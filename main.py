import asyncio
import logging
from datetime import datetime
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telegram.constants import ParseMode

# –ò–º–ø–æ—Ä—Ç—ã –Ω–∞—à–∏—Ö –º–æ–¥—É–ª–µ–π
from config import BOT_TOKEN, TEXTS, TELEGRAM_CHANNEL
from crypto_api import crypto_api
from keyboards import keyboards
from notifications import init_notification_manager

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class CryptoVektorProBot:
    def __init__(self):
        self.app = None
        self.notification_manager = None
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        user_id = str(update.effective_user.id)
        
        # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –≤—ã–±—Ä–∞–ª —è–∑—ã–∫, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        if self.notification_manager and user_id in self.notification_manager.user_languages:
            language = self.notification_manager.get_user_language(user_id)
            texts = TEXTS[language]
            await update.message.reply_text(
                texts['welcome'],
                reply_markup=keyboards.get_main_menu_keyboard(language),
                parse_mode=ParseMode.HTML
            )
        else:
            # –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤—ã–±—Ä–∞—Ç—å —è–∑—ã–∫
            await update.message.reply_text(
                "üåç Please choose your language / Bitte w√§hlen Sie Ihre Sprache / –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
                reply_markup=keyboards.get_language_keyboard()
            )
    
    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏"""
        query = update.callback_query
        await query.answer()
        
        user_id = str(query.from_user.id)
        data = query.data
        
        # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        language = 'ru'
        if self.notification_manager:
            language = self.notification_manager.get_user_language(user_id)
        texts = TEXTS[language]
        
        try:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —è–∑—ã–∫–∞
            if data.startswith('lang_'):
                lang_code = data.split('_')[1]
                if self.notification_manager:
                    self.notification_manager.set_user_language(user_id, lang_code)
                language = lang_code
                texts = TEXTS[language]
                
                await query.edit_message_text(
                    texts['welcome'],
                    reply_markup=keyboards.get_main_menu_keyboard(language),
                    parse_mode=ParseMode.HTML
                )
            
            # –í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
            elif data == 'back_to_menu':
                await query.edit_message_text(
                    texts['welcome'],
                    reply_markup=keyboards.get_main_menu_keyboard(language),
                    parse_mode=ParseMode.HTML
                )
            
            # –ì–ª–æ–±–∞–ª—å–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞
            elif data == 'global_metrics':
                await query.edit_message_text(
                    texts['loading'],
                    reply_markup=keyboards.get_back_keyboard(language)
                )
                
                global_data = await crypto_api.get_global_metrics()
                if global_data:
                    message = self.format_global_metrics(global_data, language)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_update_keyboard(language),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await query.edit_message_text(
                        texts['error'],
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # –¢–æ–ø-10 –º–æ–Ω–µ—Ç
            elif data == 'top_10_coins':
                await query.edit_message_text(
                    texts['loading'],
                    reply_markup=keyboards.get_back_keyboard(language)
                )
                
                top_coins = await crypto_api.get_top_coins()
                if top_coins:
                    message = self.format_top_coins(top_coins, language)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_update_keyboard(language),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await query.edit_message_text(
                        texts['error'],
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # –¢–æ–ø –ø–∞—Ä—ã Binance
            elif data == 'binance_pairs':
                await query.edit_message_text(
                    texts['loading'],
                    reply_markup=keyboards.get_back_keyboard(language)
                )
                
                binance_pairs = await crypto_api.get_binance_top_pairs()
                if binance_pairs:
                    message = self.format_binance_pairs(binance_pairs, language)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_update_keyboard(language),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await query.edit_message_text(
                        texts['error'],
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # –ò–Ω–¥–µ–∫—Å —Å—Ç—Ä–∞—Ö–∞/–∂–∞–¥–Ω–æ—Å—Ç–∏
            elif data == 'fear_greed':
                await query.edit_message_text(
                    texts['loading'],
                    reply_markup=keyboards.get_back_keyboard(language)
                )
                
                fear_greed = await crypto_api.get_fear_greed_index()
                if fear_greed:
                    message = self.format_fear_greed(fear_greed, language)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_update_keyboard(language),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await query.edit_message_text(
                        texts['error'],
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # –¢—Ä–µ–Ω–¥—ã
            elif data == 'trends':
                await query.edit_message_text(
                    texts['loading'],
                    reply_markup=keyboards.get_back_keyboard(language)
                )
                
                trends = await crypto_api.get_trending_coins()
                if trends:
                    message = self.format_trends(trends, language)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_update_keyboard(language),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await query.edit_message_text(
                        texts['error'],
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # DeFi –º–µ—Ç—Ä–∏–∫–∏
            elif data == 'defi_metrics':
                await query.edit_message_text(
                    texts['loading'],
                    reply_markup=keyboards.get_back_keyboard(language)
                )
                
                defi_data = await crypto_api.get_defi_metrics()
                if defi_data:
                    message = self.format_defi_metrics(defi_data, language)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_update_keyboard(language),
                        parse_mode=ParseMode.HTML
                    )
                else:
                    await query.edit_message_text(
                        texts['error'],
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            elif data == 'notifications':
                await query.edit_message_text(
                    texts['choose_coin'],
                    reply_markup=keyboards.get_coins_keyboard(language)
                )
            
            # –í—ã–±–æ—Ä –º–æ–Ω–µ—Ç—ã –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
            elif data.startswith('coin_'):
                coin_id = data.split('_', 1)[1]
                await query.edit_message_text(
                    texts['choose_interval'],
                    reply_markup=keyboards.get_intervals_keyboard(coin_id, language)
                )
            
            # –í—ã–±–æ—Ä –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
            elif data.startswith('interval_'):
                parts = data.split('_')
                coin_id = parts[1]
                interval = parts[2]
                
                if self.notification_manager:
                    self.notification_manager.add_notification(user_id, coin_id, interval)
                    
                    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–Ω–µ—Ç–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    coin_data = await crypto_api.get_coin_info(coin_id)
                    coin_name = coin_data['name'] if coin_data else coin_id
                    
                    interval_text = interval
                    if language == 'ru':
                        interval_names = {'15m': '15 –º–∏–Ω—É—Ç', '30m': '30 –º–∏–Ω—É—Ç', '1h': '1 —á–∞—Å', 
                                        '3h': '3 —á–∞—Å–∞', '6h': '6 —á–∞—Å–æ–≤', '12h': '12 —á–∞—Å–æ–≤', '24h': '24 —á–∞—Å–∞'}
                        interval_text = interval_names.get(interval, interval)
                    elif language == 'en':
                        interval_names = {'15m': '15 minutes', '30m': '30 minutes', '1h': '1 hour', 
                                        '3h': '3 hours', '6h': '6 hours', '12h': '12 hours', '24h': '24 hours'}
                        interval_text = interval_names.get(interval, interval)
                    elif language == 'de':
                        interval_names = {'15m': '15 Minuten', '30m': '30 Minuten', '1h': '1 Stunde', 
                                        '3h': '3 Stunden', '6h': '6 Stunden', '12h': '12 Stunden', '24h': '24 Stunden'}
                        interval_text = interval_names.get(interval, interval)
                    
                    message = texts['notification_set'].format(coin=coin_name, interval=interval_text)
                    await query.edit_message_text(
                        message,
                        reply_markup=keyboards.get_back_keyboard(language)
                    )
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
            elif data == 'update_info' or data == 'update_current':
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
                await query.edit_message_text(
                    texts['welcome'],
                    reply_markup=keyboards.get_main_menu_keyboard(language),
                    parse_mode=ParseMode.HTML
                )
                
        except Exception as e:
            logger.error(f"Error in button handler: {e}")
            await query.edit_message_text(
                texts['error'],
                reply_markup=keyboards.get_back_keyboard(language)
            )
    
    def format_global_metrics(self, data, language):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—É—é –º–µ—Ç—Ä–∏–∫—É"""
        change_emoji = "üü¢" if data['market_cap_change_24h'] > 0 else "üî¥"
        change_sign = "+" if data['market_cap_change_24h'] > 0 else ""
        
        if language == 'ru':
            return f"""
üåç <b>–ì–ª–æ–±–∞–ª—å–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞ –∫—Ä–∏–ø—Ç–æ—Ä—ã–Ω–∫–∞</b>

üí∞ <b>–û–±—â–∞—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è:</b> ${data['total_market_cap_usd']:,.0f}
üíπ <b>–û–±—â–∏–π –æ–±—ä–µ–º 24—á:</b> ${data['total_volume_24h_usd']:,.0f}
{change_emoji} <b>–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ 24—á:</b> {change_sign}{data['market_cap_change_24h']:.2f}%

ü™ô <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã:</b> {data['active_cryptocurrencies']:,}
üè™ <b>–ë–∏—Ä–∂–∏:</b> {data['markets']:,}

üìä <b>–î–æ–º–∏–Ω–∞—Ü–∏—è:</b>
‚Ä¢ Bitcoin: {data['market_cap_percentage'].get('btc', 0):.1f}%
‚Ä¢ Ethereum: {data['market_cap_percentage'].get('eth', 0):.1f}%

‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        elif language == 'en':
            return f"""
üåç <b>Global Crypto Market Metrics</b>

üí∞ <b>Total Market Cap:</b> ${data['total_market_cap_usd']:,.0f}
üíπ <b>Total 24h Volume:</b> ${data['total_volume_24h_usd']:,.0f}
{change_emoji} <b>Market Cap Change 24h:</b> {change_sign}{data['market_cap_change_24h']:.2f}%

ü™ô <b>Active Cryptocurrencies:</b> {data['active_cryptocurrencies']:,}
üè™ <b>Markets:</b> {data['markets']:,}

üìä <b>Dominance:</b>
‚Ä¢ Bitcoin: {data['market_cap_percentage'].get('btc', 0):.1f}%
‚Ä¢ Ethereum: {data['market_cap_percentage'].get('eth', 0):.1f}%

‚è∞ <i>Updated: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        else:  # German
            return f"""
üåç <b>Globale Krypto-Marktmetriken</b>

üí∞ <b>Gesamte Marktkapitalisierung:</b> ${data['total_market_cap_usd']:,.0f}
üíπ <b>Gesamtes 24h Volumen:</b> ${data['total_volume_24h_usd']:,.0f}
{change_emoji} <b>Marktkapitalisierung √Ñnderung 24h:</b> {change_sign}{data['market_cap_change_24h']:.2f}%

ü™ô <b>Aktive Kryptow√§hrungen:</b> {data['active_cryptocurrencies']:,}
üè™ <b>M√§rkte:</b> {data['markets']:,}

üìä <b>Dominanz:</b>
‚Ä¢ Bitcoin: {data['market_cap_percentage'].get('btc', 0):.1f}%
‚Ä¢ Ethereum: {data['market_cap_percentage'].get('eth', 0):.1f}%

‚è∞ <i>Aktualisiert: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
    
    def format_top_coins(self, coins, language):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç–æ–ø –º–æ–Ω–µ—Ç"""
        if language == 'ru':
            message = "üèÜ <b>–¢–æ–ø-10 –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</b>\n\n"
        elif language == 'en':
            message = "üèÜ <b>Top 10 Cryptocurrencies</b>\n\n"
        else:
            message = "üèÜ <b>Top 10 Kryptow√§hrungen</b>\n\n"
        
        for coin in coins:
            emoji = "üü¢" if coin['price_change_24h'] > 0 else "üî¥"
            sign = "+" if coin['price_change_24h'] > 0 else ""
            
            message += f"""
<b>{coin['rank']}. {coin['name']} ({coin['symbol']})</b>
üí∞ ${coin['price']:,.2f} {emoji} {sign}{coin['price_change_24h']:.2f}%
üìà Cap: ${coin['market_cap']:,.0f}

"""
        
        timestamp = datetime.now().strftime('%d.%m.%Y %H:%M:%S')
        if language == 'ru':
            message += f"‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {timestamp}</i>"
        elif language == 'en':
            message += f"‚è∞ <i>Updated: {timestamp}</i>"
        else:
            message += f"‚è∞ <i>Aktualisiert: {timestamp}</i>"
        
        return message
    
    def format_binance_pairs(self, pairs, language):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç–æ–ø –ø–∞—Ä—ã Binance"""
        if language == 'ru':
            message = "üí± <b>–¢–æ–ø –ø–∞—Ä—ã Binance (USDT)</b>\n\n"
        elif language == 'en':
            message = "üí± <b>Top Binance Pairs (USDT)</b>\n\n"
        else:
            message = "üí± <b>Top Binance-Paare (USDT)</b>\n\n"
        
        for i, pair in enumerate(pairs, 1):
            emoji = "üü¢" if pair['price_change_24h'] > 0 else "üî¥"
            sign = "+" if pair['price_change_24h'] > 0 else ""
            
            message += f"""
<b>{i}. {pair['symbol']}</b>
üí∞ ${pair['price']:,.4f} {emoji} {sign}{pair['price_change_24h']:.2f}%
üíπ 24h Vol: ${pair['volume_24h']:,.0f}

"""
        
        timestamp = datetime.now().strftime('%d.%m.%Y %H:%M:%S')
        if language == 'ru':
            message += f"‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {timestamp}</i>"
        elif language == 'en':
            message += f"‚è∞ <i>Updated: {timestamp}</i>"
        else:
            message += f"‚è∞ <i>Aktualisiert: {timestamp}</i>"
        
        return message
    
    def format_fear_greed(self, data, language):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∏–Ω–¥–µ–∫—Å —Å—Ç—Ä–∞—Ö–∞/–∂–∞–¥–Ω–æ—Å—Ç–∏"""
        if language == 'ru':
            message = f"""
üò∞ <b>–ò–Ω–¥–µ–∫—Å —Å—Ç—Ä–∞—Ö–∞ –∏ –∂–∞–¥–Ω–æ—Å—Ç–∏</b>

{data['emoji']} <b>–ó–Ω–∞—á–µ–Ω–∏–µ:</b> {data['value']}/100
üìä <b>–°—Ç–∞—Ç—É—Å:</b> {data['status']}

‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        elif language == 'en':
            message = f"""
üò∞ <b>Fear & Greed Index</b>

{data['emoji']} <b>Value:</b> {data['value']}/100
üìä <b>Status:</b> {data['status']}

‚è∞ <i>Updated: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        else:  # German
            message = f"""
üò∞ <b>Fear & Greed Index</b>

{data['emoji']} <b>Wert:</b> {data['value']}/100
üìä <b>Status:</b> {data['status']}

‚è∞ <i>Aktualisiert: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        
        return message
    
    def format_trends(self, trends, language):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç—Ä–µ–Ω–¥–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã"""
        if language == 'ru':
            message = "üìà <b>–¢—Ä–µ–Ω–¥–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã</b>\n\n"
        elif language == 'en':
            message = "üìà <b>Trending Coins</b>\n\n"
        else:
            message = "üìà <b>Trend-M√ºnzen</b>\n\n"
        
        for i, coin in enumerate(trends, 1):
            rank_text = f"#{coin['market_cap_rank']}" if coin['market_cap_rank'] else "N/A"
            message += f"<b>{i}. {coin['name']} ({coin['symbol']})</b> - Rank: {rank_text}\n"
        
        timestamp = datetime.now().strftime('%d.%m.%Y %H:%M:%S')
        if language == 'ru':
            message += f"\n‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {timestamp}</i>"
        elif language == 'en':
            message += f"\n‚è∞ <i>Updated: {timestamp}</i>"
        else:
            message += f"\n‚è∞ <i>Aktualisiert: {timestamp}</i>"
        
        return message
    
    def format_defi_metrics(self, data, language):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç DeFi –º–µ—Ç—Ä–∏–∫–∏"""
        if language == 'ru':
            message = f"""
üîó <b>DeFi –ú–µ—Ç—Ä–∏–∫–∏</b>

üí∞ <b>DeFi –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è:</b> ${data['defi_market_cap']:,.0f}
‚ö° <b>ETH –ö–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è:</b> ${data['eth_market_cap']:,.0f}
üìä <b>DeFi/ETH –û—Ç–Ω–æ—à–µ–Ω–∏–µ:</b> {data['defi_to_eth_ratio']:.2f}%
üíπ <b>–û–±—ä–µ–º —Ç–æ—Ä–≥–æ–≤ 24—á:</b> ${data['trading_volume_24h']:,.0f}
üèÜ <b>DeFi –î–æ–º–∏–Ω–∞—Ü–∏—è:</b> {data['defi_dominance']:.2f}%

‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        elif language == 'en':
            message = f"""
üîó <b>DeFi Metrics</b>

üí∞ <b>DeFi Market Cap:</b> ${data['defi_market_cap']:,.0f}
‚ö° <b>ETH Market Cap:</b> ${data['eth_market_cap']:,.0f}
üìä <b>DeFi/ETH Ratio:</b> {data['defi_to_eth_ratio']:.2f}%
üíπ <b>24h Trading Volume:</b> ${data['trading_volume_24h']:,.0f}
üèÜ <b>DeFi Dominance:</b> {data['defi_dominance']:.2f}%

‚è∞ <i>Updated: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        else:  # German
            message = f"""
üîó <b>DeFi-Metriken</b>

üí∞ <b>DeFi-Marktkapitalisierung:</b> ${data['defi_market_cap']:,.0f}
‚ö° <b>ETH-Marktkapitalisierung:</b> ${data['eth_market_cap']:,.0f}
üìä <b>DeFi/ETH-Verh√§ltnis:</b> {data['defi_to_eth_ratio']:.2f}%
üíπ <b>24h Handelsvolumen:</b> ${data['trading_volume_24h']:,.0f}
üèÜ <b>DeFi-Dominanz:</b> {data['defi_dominance']:.2f}%

‚è∞ <i>Aktualisiert: {datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</i>
            """
        
        return message
    
    async def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        if not BOT_TOKEN:
            logger.error("BOT_TOKEN not found in environment variables!")
            return
        
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        self.app = Application.builder().token(BOT_TOKEN).build()
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        self.notification_manager = init_notification_manager(self.app.bot)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CallbackQueryHandler(self.button_handler))
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        self.notification_manager.start_scheduler()
        
        logger.info("Bot started successfully!")
        
        try:
            # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
            await self.app.run_polling(allowed_updates=Update.ALL_TYPES)
        except Exception as e:
            logger.error(f"Error during polling: {e}")
        finally:
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
            if self.notification_manager:
                self.notification_manager.stop_scheduler()
            logger.info("Bot stopped")

async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    bot = CryptoVektorProBot()
    await bot.run()

def start_bot():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π event loop"""
    try:
        # –ü–æ–ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å asyncio.run()
        asyncio.run(main())
    except RuntimeError as e:
        if "cannot be called from a running event loop" in str(e):
            # –ï—Å–ª–∏ event loop —É–∂–µ –∑–∞–ø—É—â–µ–Ω, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
            logger.info("Creating new event loop...")
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                loop.run_until_complete(main())
            finally:
                loop.close()
        else:
            raise e
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        # –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ —Å –Ω–æ–≤—ã–º event loop
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(main())
            loop.close()
        except Exception as final_error:
            logger.error(f"Final error: {final_error}")
            raise

if __name__ == '__main__':
    try:
        start_bot()
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Bot error: {e}")